# USBマウスが動かない件について

ホストコントローラ（xHC）のベンダーIDがNEC（0x1033）になっていた。
Intel製のxHC用にEHCIをxHCIに変更したように、NEC製のxHCもこの処理が必要なのでは。
`main.cpp`では、`SwitchEhci2Xhci()`を呼び出すのは、Intel製の場合のみ。

`SwitchEhci2Xhci()`では、Intel製のEHCIに限定して、PCIコンフィギュレーション空間を操作してEHCIをxHCIに変更しているっぽい。

解決した。
QEMUのウィンドウをアクティブにしていないだけだった。ウィンドウだけがアクティブになっていても、マウスで一回クリックしないと認識されないみたい。


# QEMUのxHCについて

何か設定でホストコントローラーを追加したりできるのか？

# ホスト側のUSBデバイスについて

Win10の方のデバイスマネージャーでは、Intel製のxHCが表示されている。
QEMUにとってホストはUbuntuなので、UbuntuのxHCがどうなっているかを確認すればよいのか？

ちょっと調べた限り、WSL2でUSBデバイス等のPCIデバイスを直接見る方法がないっぽい。
マウス等の入力はWindowsが処理しているのか？

# csとssで3bitずらしている理由

レジスタの構造で、セグメントのindexを設定するのがbit3以降だから。

[参考資料]{https://babyron64.hatenablog.com/entry/2017/12/22/210124}

# C++のイテレータについて

``Layer.cpp``の``FindLayer()``にある``std::find_if()``での使われ方がよくわからない。
``layers_.begin()``と``layers_.end()``は、イテレータらしい。
イテレータを比較する文が出てくるけど、イテレータを比較するってどういうこと？

# WindowクラスのDrawTo()にwriterを渡す必要があるのか

Windowクラスはメンバ変数としてwriterを持っているのに、DrawTo()で外部のwriterに対してWindowの内容を描画することがるのか？

これに対する回答は、Windowクラスが持っているメンバ変数のwriterはあくまでそのWindowクラスの描画領域を疑似的にあらわしたもの。
DrawTo()で受け取るwriterは、実際の画面の描画領域であり、UEFIからもらった画面のビットマップそのもの。

# osbook_day14cのメモ

タスクの優先度をつける

TaskManagerに
  - 現在の実行レベル
  - 実行レベルごとのキュー
  - 実行レベルを変更するフラグ
を実装する。

Taskに
  - タスク自身の実行レベル
  - タスクが現在実行可能状態かどうか
を持たせる。

## Sleepでやること

タスクが実行可能状態であれば、実行可能状態を解除する。

引数のタスクが実行中の場合は、SwitchTask()を実行する。
実行レベルの変更とかはSwitchTask()に任せる。

実行中でない場合、そのタスクの実行レベルのキューからタスクを削除する。

## Wakeupでやること

Wakeupの仕事は、引数のタスクを引数のレベルのキューに突っ込むこと。

引数のタスクが実行可能状態であれば、実行レベルを変更する。
実行レベルの変更はChangeLevelRunningに移譲する。

引数のタスクを実行可能状態に変更する。

引数の実行レベルのキューに引数のタスクを突っ込む

引数の実行レベルが現在の実行レベルよりも高ければ、実行レベル変更フラグを立てる。
  => 実行レベルの変更はSwitchTask()が実行されるまで待つ。

## ChangeLevelRunningでやること

実行可能状態のタスクの優先度を変更する。

引数のタスクのレベルと引数のレベルに変化が無ければ何もせずに終了する。

引数のタスクが現在実行中出ない場合、引数のレベルのキューに引数のタスクを突っ込む。
引数のレベルが現在の実行レベルより大きい場合は、実行レベル変更フラグを立てる。

引数のタスクが現在実行中の場合、現在のキューから削除して引数のレベルのキューに突っ込む。
タスクは実行中なので、現在の実行レベルを引数のレベルに合わせる。
引数のレベルにかかわらず、実行レベル変更フラグを立てる。
